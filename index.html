<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>WebAR Atom - Following Three.js Official Patterns1</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
body {
  margin: 0;
  background-color: #000;
  color: #fff;
  font-family: Monospace;
  font-size: 13px;
  line-height: 24px;
  overscroll-behavior: none;
}

#info {
  position: absolute;
  top: 10px;
  width: 100%;
  text-align: center;
  z-index: 100;
  display: block;
}

#info a {
  color: #f00;
  font-weight: bold;
  text-decoration: underline;
}
</style>
</head>
<body>

<div id="info">
  <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> ar - atom placement<br/>
  Tap to place atoms - multiple atoms supported
</div>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.module.js";
import { ARButton } from "https://cdn.jsdelivr.net/npm/three@0.153.0/examples/jsm/webxr/ARButton.js";

let container;
let camera, scene, renderer;
let controller1, controller2;

let reticle;
let atom;
let electrons = [];

let hitTestSource = null;
let hitTestSourceRequested = false;

// Interaction state
let isManipulating = false;
let selectedObject = null;

init();

function init() {

  container = document.createElement('div');
  document.body.appendChild(container);

  scene = new THREE.Scene();

  camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

  const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 3);
  light.position.set(0.5, 1, 0.25);
  scene.add(light);

  //

  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setAnimationLoop(animate);
  renderer.xr.enabled = true;
  container.appendChild(renderer.domElement);

  //

  document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] }));

  //

  function onSelect() {

    if (reticle.visible && !atom) {
      // Place atom
      atom = createAtom();
      reticle.matrix.decompose(atom.position, atom.quaternion, atom.scale);
      scene.add(atom);
      
      // Hide reticle once atom is placed
      reticle.visible = false;
      
    } else if (atom) {
      // Toggle manipulation mode
      isManipulating = !isManipulating;
      selectedObject = isManipulating ? atom : null;
      
      // Visual feedback for manipulation mode
      if (isManipulating) {
        atom.children.forEach(child => {
          if (child.material && child.material.emissive) {
            child.material.emissive.setHex(0x444444);
          }
        });
      } else {
        atom.children.forEach(child => {
          if (child.material && child.material.emissive) {
            child.material.emissive.setHex(0x000000);
          }
        });
      }
    }

  }

  // Follow the exact Three.js pattern for controllers
  controller1 = renderer.xr.getController(0);
  controller1.addEventListener('select', onSelect);
  scene.add(controller1);

  controller2 = renderer.xr.getController(1);
  controller2.addEventListener('select', onSelect);
  scene.add(controller2);

  // Create reticle exactly like Three.js examples
  reticle = new THREE.Mesh(
    new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2),
    new THREE.MeshBasicMaterial()
  );
  reticle.matrixAutoUpdate = false;
  reticle.visible = false;
  scene.add(reticle);

  //

  window.addEventListener('resize', onWindowResize);

}

function createAtom() {
  const group = new THREE.Group();
  
  // Nucleus
  const nucleusGeo = new THREE.SphereGeometry(0.05, 16, 16);
  const protonMat = new THREE.MeshPhongMaterial({ 
    color: 0xff0000,
    emissive: 0x000000
  });
  const neutronMat = new THREE.MeshPhongMaterial({ 
    color: 0x0000ff,
    emissive: 0x000000
  });

  for (let i = 0; i < 8; i++) {
    const mat = i % 2 === 0 ? protonMat : neutronMat;
    const particle = new THREE.Mesh(nucleusGeo, mat);
    particle.position.set(
      (Math.random() - 0.5) * 0.1,
      (Math.random() - 0.5) * 0.1,
      (Math.random() - 0.5) * 0.1
    );
    group.add(particle);
  }

  // Electrons
  const electronGeo = new THREE.SphereGeometry(0.02, 12, 12);
  const electronMat = new THREE.MeshPhongMaterial({ 
    color: 0x00ff00,
    emissive: 0x002200
  });
  
  electrons = []; // Reset electrons array
  for (let i = 0; i < 3; i++) {
    const electron = new THREE.Mesh(electronGeo, electronMat);
    electron.userData = { 
      angle: (i / 3) * Math.PI * 2, 
      radius: 0.3 + 0.05 * i,
      speed: 0.02 + Math.random() * 0.01
    };
    group.add(electron);
    electrons.push(electron);
  }

  // Orbital rings for visual reference
  for (let i = 0; i < 3; i++) {
    const ring = new THREE.Mesh(
      new THREE.RingGeometry(0.29 + 0.05 * i, 0.31 + 0.05 * i, 32),
      new THREE.MeshBasicMaterial({ 
        color: 0x444444, 
        transparent: true, 
        opacity: 0.2,
        side: THREE.DoubleSide 
      })
    );
    ring.rotation.x = -Math.PI / 2;
    group.add(ring);
  }

  return group;
}

function onWindowResize() {

  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();

  renderer.setSize(window.innerWidth, window.innerHeight);

}

//

function animate(timestamp, frame) {

  // Animate electrons
  if (atom && electrons.length > 0) {
    electrons.forEach(electron => {
      electron.userData.angle += electron.userData.speed;
      const radius = electron.userData.radius;
      electron.position.set(
        Math.cos(electron.userData.angle) * radius,
        Math.sin(electron.userData.angle * 0.3) * 0.1, // Slight vertical movement
        Math.sin(electron.userData.angle) * radius
      );
    });
  }

  if (frame) {

    const referenceSpace = renderer.xr.getReferenceSpace();
    const session = renderer.xr.getSession();

    // Hit test logic - follows Three.js pattern exactly
    if (hitTestSourceRequested === false) {

      session.requestReferenceSpace('viewer').then(function (referenceSpace) {

        session.requestHitTestSource({ space: referenceSpace }).then(function (source) {

          hitTestSource = source;

        });

      });

      session.addEventListener('end', function () {

        hitTestSourceRequested = false;
        hitTestSource = null;

      });

      hitTestSourceRequested = true;

    }

    if (hitTestSource) {

      const hitTestResults = frame.getHitTestResults(hitTestSource);

      if (hitTestResults.length && !atom) {

        const hit = hitTestResults[0];

        reticle.visible = true;
        reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);

      } else if (!atom) {

        reticle.visible = false;

      }

    }

    // Handle manipulation input using WebXR input sources
    handleXRInput(frame, referenceSpace);

  }

  renderer.render(scene, camera);

}

function handleXRInput(frame, referenceSpace) {
  if (!isManipulating || !selectedObject) return;

  const session = renderer.xr.getSession();
  
  // Handle input sources for manipulation
  for (let inputSource of session.inputSources) {
    
    // Check if input source has target ray space and gamepad
    if (inputSource.targetRaySpace && inputSource.gamepad) {
      
      const pose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
      if (!pose) continue;

      // Get the current input state
      const primaryPressed = inputSource.gamepad.buttons[0] && inputSource.gamepad.buttons[0].pressed;
      const primaryValue = inputSource.gamepad.buttons[0] ? inputSource.gamepad.buttons[0].value : 0;
      
      if (primaryPressed) {
        // Use input pose to manipulate object
        const inputPosition = new THREE.Vector3().setFromMatrixPosition(pose.transform.matrix);
        
        // Simple manipulation: move object based on controller position
        const targetPosition = inputPosition.clone();
        targetPosition.y += 0.1; // Offset slightly above controller
        
        // Smooth movement
        selectedObject.position.lerp(targetPosition, 0.1);
        
        // Scale based on input pressure if available
        if (primaryValue > 0) {
          const targetScale = 0.5 + primaryValue * 1.5;
          selectedObject.scale.setScalar(targetScale);
        }
      }
      
      // Handle secondary input for rotation if available
      const secondaryPressed = inputSource.gamepad.buttons[1] && inputSource.gamepad.buttons[1].pressed;
      if (secondaryPressed) {
        selectedObject.rotation.y += 0.02;
      }
    }
  }
}

</script>
</body>
</html>